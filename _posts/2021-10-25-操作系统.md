---
layout: post
title: "存储器管理"
subtitle: ""
date: 2021-10-25
author: "Bedoom"
header-style: test
tags: 
  - 操作系统
---



# 存储器管理

## 01概述

* **存储体系**

  计算机系统中的存储器一般分为两类：内存和外存。

  内存可以分成系统区和用户区。系统区是用于系统操作的，用户区是分配给用户程序使用的。

* **存储管理的目的**

  为用户提供方便、安全和足够大的存储空间。

* **存储管理的任务**

  1. 地址转换

     要使用户方便、高效的使用存储空间，地址转换是必须的。

     逻辑地址：一般指相对地址，使程序首地址为0，其他指令都是相对于首地址的地址。

     物理地址：指绝对地址，存储单元在计算机存储系统中的编号。

  2. 内存的分配和回收

     当用户提出申请时，操作系统按照策略分配给用户合适的内存，并修改表内的有关项；当用户程序执行完毕后，操作系统负责及时回收相关存储空间，并修改表内的有关项。
     
  3. 内存的地址保护
  
     一般是由硬件和软件共同配合实现的。
  
  4. 内存的共享
  
     共享内存资源
  
     共享内存中的某些区域
  
  5. 内存的扩充
  
     内存的扩充不是指物理层面上硬件的扩充，是指逻辑扩充，即虚拟内存。
  
* **程序的链接和装入**

  用户源文件变成计算机可执行文件分为三步：编译、链接和装入。

  * 程序的链接
    1. 静态链接方式
    2. 装入时动态链接方式
    3. 运行时动态链接方式
  * 程序的装入
    1. 绝对装入方式（编译时）
    2. 可重定位装入方式（静态重定向）
    3. 动态运行时装入方式（动态重定向）

## 02连续存储管理方式

* **单一连续分配**

  * 基本思想

    内存的用户区每一次都只分给一个程序使用

  * 存储保护机制

    基址寄存器和界限地址寄存器

  * 特点

    内存的分配和回收十分简单，但内存利用率低的离谱

* **分区分配**

  为适应多道程序设计技术而产生的最简单的存储管理方式。

  * 固定分区

    > * 基本思想
    >
    >   系统**预先**将内存的用户区分成若干个内存块，这个内存块就称为一个分区。在程序装入时，根据所需内存大小，操作系统会按照策略来分配分区。
    >
    >   <div align=center>    <img width = "50%" height = "50%" style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"     src="https://raw.githubusercontent.com/bedoom/imges/main/image-20211026171418958.png">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;"></div> </div>
    >
    > * 存储保护机制
    >
    >   上下限寄存器或基址、长度寄存器
    >
    > * 特点
    >
    >   简单，适用于专用系统；内存利用不充分，程序大小受分区大小影响。

  * 可变分区

    > * 基本思想
    >
    >   程序在装入时**动态分配**内存资源；若可用内存<程序需要内存，则程序等待。
    >
    > * 分配中的数据结构
    >
    >   常用的数据结构有已分分区表和空闲分区表。
    >
    >   <div align=center>    <img width = "50%" height = "50%" style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"     src="https://raw.githubusercontent.com/bedoom/imges/main/image-20211026165956585.png">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;"></div> </div>
    >
    > * 优缺点：
    >
    >   1. 适用于多道程序设计，提高了内存利用率
    >   2. 实现简单，代价低
    >   3. 必须要分配连续的内存空间
    >   4. 碎片问题严重，内存利用率其实还可以提高
    >   5. 不能对内存进行逻辑扩充

* **分区分配算法**

  * 首次适应算法

    每次从链首开始顺序查找，直到找到一个可以满足内存大小需要的分区为止。

  * 循环首次适应算法

    在进行内存分配时，从上次找到的空闲分配的下一个分区开始，直到找到一个可以满足条件的分区为止。

  * 最佳适应算法

    选择满足程序内存大小，且最小的空闲分区。

  * 最差适应算法

    选择满足程序内存大小，且最大的空闲分区。
  
* **内存分区分配操作图**

  ```flow
  st=>start: Start   
  
  op1=>operation: 从链表头开始查找
  op2=>operation: 继续检索下一个链表项 
  op3=>operation: 从该分区中划出u.size大小的分区
  op4=>operation: 把该分区从链中移出
  op5=>operation: 将该分区分配给请求者，修改有关数据结构
  
  cond1=>condition: 检索完否
  cond2=>condition: m.size-u.size>=0
  cond3=>condition: m.size-u.size<=size
  e1=>end: 返回
  e2=>end: 返回
  
  
  st->op1->cond1
  cond1(yes,right)->e1
  cond1(no)->cond2
  cond2(no, right)->op2(right)->cond1
  cond2(yes)->cond3
  cond3(no)->op3->op5->e2
  cond3(yes, right)->op4->op5
  

* 内存分区回收操作

  当程序运行完毕释放内存时，系统根据回收区的首址，从空闲分区表中找到相应的插入点，进行回收。

  * 若回收区与插入点的前一个节点相邻，则这两个分区合并；
  * 若回收区与插入点的后一个节点相邻，则将这两个分区合并；
  * 若回收区与上下两个插入点的分区都相邻，则将三个分区合并；
  * 若回收区没有相邻节点，则单独作为一个分区加入的空闲分区表中。

  给定数据结构：

  ```c++
  struct{
      float address;
      float length;
      int flag;  // 已分配区表登记栏标志
  }used_table[n];
  
  struct {
      float address;
      float length;
      int flag;  // 空闲区表登记栏标志
  }free_table[m];
  ```

  设计分配回收算法：

  ```c++
  k=-1;
  for(i = 0; i < m; i++)
      if(free_table[i].length >= xk && free_table[i].flag==1)
          if(k==-1||free_table[i].length<free_table[k].length)
              k=i;
  if(k==-1) {
      cout << "无可用分区" << endk;
      return 0;
  }
  
  if(free_table[k].length-xk <= minisize){
      free_table[k].flag=0;
      ad=free_table[k].address;
      xk=free_table[k].length;
  }else {
      free_table[k].length=free_table[k].length-xk;
      ad=free_table[k].address+free_table[k].length
  }
  ```

  ```c++
  // 取得归还分区的起始地址S和长度L
  S=used_table[s].address;
  L=used_table[s].length;
  j=-1;
  k=-1;
  i=0;
  while(i<m && (j==-1||k==-1)){
      if(free_table[i].flag == 1){
          if(free_table[i].address+free_table[i].length==S)
              k=i;
          if(free_table[i].address==S+L)
              j=i;
      }
      i++;
  }
  if(k!=-1)
      if(j!=-1){
          free_table[k].length=free_table[i].length+free_table[k].length+L;
          free_table[j].flag=0;
      }else
          free_table[k].length=free_table[k].length+L;
  else
      if(j!=-1){
          free_table[j].address=S;
          free_table[j].length=free_table.length+L;
      }else{
          // 寻找空闲栏t；这不太明白...........
          free_table[t].address = S;
          free_table[t].length = L;
          free_table[t].flag = 1;
      }
  ```

  

## 03分页存储管理方式

* 基本思想

  将计算机内存空间分成相同大小的存储空间，每一个这样的存储空间就叫做物理块或页框。

  页表的作用是完成页号和物理块号映射。

* 动态地址变换

  地址变换就是页号变换成相应的物理地址。当想解决方法时，很自然地想到页表。因此可以借助页表进行地址转换。

  <div align=center>    <img width = "50%" height = "50%" style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"     src="https://raw.githubusercontent.com/bedoom/imges/main/image-20211029233238569.png">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;"></div> </div>

  * 快表

    当用逻辑地址进行内存读写时，需要访问两次内存。第一次是访问页表读出相应的物理地址，第二次才是进行对应内存读写，这样会比普通执行慢一倍。所以，思考一下如何改进一下呢？试想如果常用指令仅仅访问一次内存，这样就能大大提高效率，因此引入快表。

    <div align=center>    <img width = "50%" height = "50%" style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"     src="https://raw.githubusercontent.com/bedoom/imges/main/image-20211029233238569.png">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;"></div> </div>

* 两级和多级页表

  现代的大多数计算机系统都支持非常大的逻辑地址空间，此时，页表就变得非常大，要为它分配一大段连续的内存空间将变得十分困难

   **解决办法：**

  ①采用离散分配方式来解决难以找到一块连续的内存空间问题——多级页表。

  ②只将当前需要的部分页表项调入内存，其余的页表项仍驻留在磁盘上，需要时再调入。

* 分配与回收

  采用位示图的方法来作为分配和回收的数据结构。0代表未分配，1代表已分配。

  <div align=center>    <img width = "50%" height = "50%" style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"     src="https://raw.githubusercontent.com/bedoom/imges/main/image-20211030104705328.png">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;"></div> </div>

## 04分段存储管理方式

## 05段页式存储管理方式

