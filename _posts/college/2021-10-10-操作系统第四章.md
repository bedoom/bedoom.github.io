---
layout: post
title: "操作系统第四章"
subtitle: "进程同步与通信"
date: 2021-10-10
author: "Bedoom"
header-style: text
tags: 
  - 操作系统
---



# 4.1 进程间的相互作用

## 4.1.1 进程间的联系

* 资源共享关系：

  多个进程之间彼此无关。各进程处于==竞争==关系，进程同步的主要任务是保证诸进程能互斥地访问临界资源。

* 相互合作关系：

  例如，在输入进程、计算进程和打印进程三者之间，就是一个相互合作的关系。此时进程同步的主要任务是保证相互合作的进程在执行次序上的协调，不会出现时间上的差错。

****

1. 临界资源

   一个时刻（==宏观==）只允许一个进程使用的资源称为临界资源，多个进程必须互斥地访问临界资源。

2. 临界区

   每个进程访问临界资源的==那段代码==称为临界区。保证进程互斥地进入临界区，便可保证临界资源的互斥访问。因此需要在临界区的前面加上一段检查临界资源是否被占用的代码，在临界区后加上一段释放临界区标志的代码。

3. 同步机制应遵循的**准则**：

   * 空闲让进
   * 忙则等待
   * 有限等待
   * 让权等待
   
4. 安全状态：所谓安全状态是指系统能按某种顺序如<P1,P2,...,Pn>(称<P1,P2,...Pn>序列为安全序列)，来为每个进程分配其所需资源，直到最大需求，使每个进程都可顺序完成。若系统不存在这样一个安全序列，则称系统处于不安全状态。

5. 产生死锁的四个必要条件：

   * 互斥条件：一个资源每次只能被一个进程使用。 
   *  请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。 
   * 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。 
   * 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。

## 4.1.2 利用软件方法解决进程互斥问题

由于软件的缘故，只能实现“空闲等待”和“忙则等待”，并不能实现“有限等待”和“让权等待”。

```c++
P1:
while(1)
{
    ...
    flag[0] = 1; turn = 2;
    while(flag[1] && turn = 2) no-op;
    critical section
    flag[0] = 0;
    ...
}
```

假如P1进程一直不放临界资源，那么P2就会陷入死等，易出现“**饿死**”现象。由于软件方法并不能控制下层进程调度的速度，因此，不能实现“有限等待”和“让权等待”。

## 4.1.3 利用硬件方法解决进程互斥问题

因为利用软件方法来解决进程互斥有很大的局限性，因而现在已经很少采用。现在计算机已提供一些特殊的硬件指令，这些指令允许对一个字中的内容进行检测和修正，或交换两个字的内容等。

* 利用Test-and-Set指令实现互斥

  为实现进程对临界资源的互斥访问，需要定义一个全局变量lock，lock=0 表示资源空闲；lock=1 表示资源占用。TS记录lock的状态，并将1赋值给lock，表示资源区关闭。

  ```c++
  while(1)
  {
      ...
      while(TS(lock)) do no-op;
      critical section
      lock = 0
      ...
  }
  ```

  这很明显可以看出并不满足“有限等待”原则。

* 利用Swap指令实现进程互斥

  ```c++
  while(1)
  {
      ...
      key = 1;
      do {
          Swap(lock, key);
      }while(key);
      critical section
      lock=0;
      ...
  }
  ```

  这硬件指令不顶用呀。

## 4.1.4 信号量机制

这是目前最有效解决进程互斥问题的一个算法了。

* 记录性信号量机制

  **实体**：资源数目**value**，进程链表**L**。

  **原子操作**（不可中断的操作）：wait AND signal

  ```c++
  semaphore mutex=1;
  void procedure1()
  {
      while(1)
      {
          ...
          wait(mutex);
          critical section
          signal(mutex);
          ...
      }
  }
  void procedure2()
  {
      while(1)
      {
          ...
          wait(mutex);
          critical section
          signal(mutex);
          ...
      }
  }
  main()
  {
      cobegin(){
          procedure1();
          procedure2();
      }
  }
  ```

  **注意**：wait和signal必须成对出现。

  * ==利用信号量描述程序或语句之间的前趋关系==


## 4.1.5 经典进程同步问题

经典进程同步问题：生产者-消费者，读者-写者问题，哲学家进餐问题。

解题步骤：

1. 将进程执行过程一步一步描述。
2. 分析执行条件，将条件一一记录。
3. 比较各个条件，将同一条件归为一个，设信号量表示。
4. 设置信号量初值。
5. 加入wait，signal操作。
6. 检查。

----

* 生产者-消费者问题

  ```C++
  semaphore mutex=1, empty=n, full=0;
  item buffer[n];
  int in=out=0;
  void produre(){
      while(1){
          ...
          produce an item in nextp;
          ...
          wait(empty);
          wait(mutex);
          buffer[in]=nextp;
          in = (in+1) % n;
          signal(mutex);
          signal(full);
      }
  }
  
  void consumer(){
      while(1){
          ...
          wait(full);
          wait(mutex);
          nextc=buffer[out];
          out=(out+1)%n;
          signal(mutex);
          signal(empty);
          ...
          consume the item in nextc;
          ...
      }
  }
  
  main(){
      cobegin(){
          producer();
          consumer();
      }
  }
  ```

  **注意：**

  1. wait和signal必须同时出现。
  2. 先执行对资源信号的wait操作再执行对互斥信号的资源操作。

* 读者-写者问题

  ```c++
  semaphore rmutex=mutex=1;
  int readcount=0;
  void reader(int i){
      while(1){
          wait(rmutex);
          if(readcount==0)
              wait(mutex);
          readcount++;
          signal(rmutex);
          perform read operation;
          wait(rmutex);
          readcount--;
          if(readcount==0)
              signal(mutex);
          signal(rmutex);
      }
  }
  
  void writer(int j){
      while(1){
          ...
          wait(mutex);
          perform writer operation;
          signal(mutex);
      }...
  }
  
  main(){
      cobegin{
          reader(1);
          ...
          reader(n);
          writer(1);
          ...
          writer(n);
      }
  }
  ```

* 哲学家进餐问题

  **题目：**

  > 有5位哲学家，他们的生活方式是交替地进行思考和进餐。哲学家们共用一张圆桌，分别坐在周围的5张椅子上。在圆桌上有5个碗和5支筷子，平时哲学家进行思考，饥饿时便试图取用其左、右最靠近他的桌子的筷子，只有在他拿到两支筷子时才能进餐。进餐完毕后，放下筷子继续思考。

  筷子是临界资源，一段时间内只允许一个哲学家使用。

  ```c++
  semaphore chopstick[5]={1, 1, 1, 1, 1};
  void process(int i){
      while(1){
          wait(chopstick[i]);
          wait(chopstick[(i+1)%5]);
          ...
          eat();
          ...
          signal(chopstick[i]);
          signal(chopstick[(i+1)%5]);
          ...
          think;
      }
  }
  ```

  如若不加以限制，会产生死锁情况。对于这样情况通常采用一下几种解决方法:

  1. 至多只允许4位哲学家同时进餐。
  2. 仅当哲学家左右的筷子都可用时进餐。
  3. 规定奇数哲学家先拿左边筷子，偶数哲学家先拿右边筷子。