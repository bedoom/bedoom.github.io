I"<!--more-->

<h2 id="简答">简答</h2>

<ol>
  <li>
    <p>存储器的目的：为用户提供方便、提供安全足够大的存储空间。</p>
  </li>
  <li>
    <p>用户源程序变成可执行程序的步骤：编译、链接和装入。</p>
  </li>
  <li>
    <p>链接方式：静态链接、装入时动态链接和运行时动态链接。</p>
  </li>
  <li>
    <p>在存储管理中程序的装入有哪几种，分别在什么时候发生？</p>

    <ul>
      <li>绝对装入方式 （编译时）</li>
      <li>可重定位装入方式，又称静态重定位（装入内存时）</li>
      <li>动态运行时装入方式，又称动态重定向（运行时）</li>
    </ul>
  </li>
  <li>
    <p>解释可变分区管理中的紧凑技术，什么时候紧凑最合适？</p>

    <p>紧凑技术是处理“碎片”问题的一种。通过移动，将多个小分区拼接成一个大分区的方法称为紧凑。通常仅在系统接收到程序所发出的内存申请命令，且每个空闲区域单独均不能满足，但所有空闲分区之和能够满足请求时才进行一次紧凑。</p>
  </li>
  <li>
    <p>简述分页存储管理的基本思想和页表的作用。</p>

    <ul>
      <li>
        <p>存储空间按相同长度为单位进行等划分，按相同单位等分进程地址空间。把内存的存储空间也分成大小相同的片段，叫做物理块或页框(Frame)。</p>
      </li>
      <li>
        <p>把每个进程的地址空间(逻辑空间)分成一些大小和物理块相同的片段，叫做页面或页(Page)。</p>
      </li>
      <li>
        <p>在分配存储空间时，总是以块为单位，按照程序的页数分配物理块。分配的物理块可以连续也可以不连续</p>
      </li>
    </ul>

    <p>页表的作用：实现从页号到物理块号的转换。</p>

    <div align="center">    <img width="50%" height="50%" style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://gitee.com/bedoom/images/raw/master/202112111413026.png" />    <br />    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;"></div> </div>
  </li>
  <li>
    <p>为什么有的页式存储管理中要采用多级页表？</p>

    <p>如今计算机都支持索引非常大的逻辑地址空间，但要连续分配如此大的页表变得十分困难。因此采用多级页表方式。</p>
  </li>
  <li>
    <p>画出页式存储管理地址转换示意图。</p>

    <p><img src="https://gitee.com/bedoom/images/raw/master/202112111427977.png" alt="image-20211211142705863" class="shadow" /></p>
  </li>
  <li>
    <p>当系统中的地址空间非常大时(例如32位),会给页表的设计带来什么问题，如何解决？</p>

    <p>当系统的地址空间非常大时，连续分配如此之大的页表会变得极为困难，因此可以采用多级页表来管理，同时为了提高检索效率，可以另外设置一个快表。</p>
  </li>
  <li>
    <p>在存储管理中，既有页式存储管理也有段式存储管理方式，页和段有哪些区别?</p>

    <ul>
      <li>页式是信息的物理单位，对用户来说，是透明的；段式是信息的逻辑单位，对用户来说是，不透明的。</li>
      <li>页的大小固定，由系统决定；段的大小不固定，由用户程序决定。</li>
      <li>页是一维结构；段是二维结构。</li>
    </ul>
  </li>
</ol>

<h2 id="连续分配方案">连续分配方案</h2>

<p><strong>数据结构</strong>有已分分区表和空闲分区表</p>

<p>已分分区表中记录当前已经分配给用户程序的内存分区，包括分区序号、开始地址、分区大小等信息。空闲分区表记录了当前内存中空闲分区的情况，包括分区序号、开始地址、分区大小</p>

<p><strong>分配方案</strong>:假定需求为u.size</p>

<p>在空闲分区表找到满足u.size需求的（第一个、最大的、最小的）空闲分区</p>

<p>若未找到满足条件的空闲分区，分配失败；若找到，假定找到分区的大小为m.size，若m.size-u.size小于给定阈值，全部分配，否则切出u.size大小区域，并登记在已分分区表</p>

<p><strong>回收方案</strong>：</p>

<p>假定程序归还的分区起始地址为S，长度为L，则：</p>

<p>① 归还区有下邻空闲区，修改下邻分区栏起始地为S，长度增加L
② 归还区有上邻空闲区，上邻分区长度增加L
③ 归还区既有上邻空闲区又有下邻空闲区,上邻空闲区长度为三个分区和，下邻空闲区登记项删除
④ 归还区既无上邻空闲区又无下邻空闲区,应该在空闲区表中查找一个状态为“空”的栏目登记</p>

<h2 id="离散分配方案">离散分配方案</h2>

<p><strong>数据结构</strong>：采用位示图的方法，用一位来表示一块内存块，用一位的两种状态来表示内存块是空闲还是已分配 ，空闲块总数</p>

<p><strong>分配方法</strong>：
  根据进程的页数得到其所需的物理块数，检查空闲物理块总数是否足够，不能满足则分配失败；能满足该进程的需求，则查位示图中为“0”的位，计算出物理块号，并写入进程的页表。位示图中第i个字的第j位对应的物理块号为：
        块号=i×位示图中的字长+j</p>

<p><strong>回收方法</strong>：
   根据回收进程的页表，依次计算每个物理块所对应的位在位示图中的位置第i字，第j位，并将该位置0，最后增加空闲物理块总数。
         i=块号/位示图中的字长
         j=块号%位示图中的字长</p>

<h2 id="可变分区碎片问题">可变分区碎片问题</h2>

<p>连续分配方案：</p>

<p><strong>数据结构</strong>有已分分区表和空闲分区表</p>

<p>已分分区表中记录当前已经分配给用户程序的内存分区，包括分区序号、开始地址、分区大小等信息 空闲分区表记录了当前内存中空闲分区的情况，包括分区序号、开始地址、分区大小</p>

<p><strong>方案</strong>：</p>

<p>1.将已分分区按照地址排序（假设n个分区，且都放在已分分区表前n项,s为用户区起始地址）
2.For i=0 to n-1
  { 将第i栏分区移动到s处，修改已分分区表；
   s=s+第i栏分区长度；
  }
3.统计空闲分区总和，空闲区分表清空；
4.第0栏登记一个空闲分区项，地址s，长度所有空闲分区和。</p>
:ET